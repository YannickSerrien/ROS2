# Composition Example

Complete demonstration of ROS2 node composition with zero-copy intra-process communication for high-performance robotics applications.

## What's Included

This package demonstrates node composition through two complete examples:

### Examples

**1. Talker/Listener** (Basic)
- Simple string message passing
- Demonstrates basic composition concepts
- Shows zero-copy for small messages

**2. Image Pipeline** (Realistic)
- Simulated camera publishing images (640x480 RGB)
- Image processor (color inversion)
- Demonstrates performance gains with large messages

### Components

All nodes are built as **components** (shared libraries) that can run:
- **Composed**: Multiple nodes in ONE process (zero-copy, fast)
- **Separate**: Each node in OWN process (traditional, slower)

## Building

```bash
# From workspace root
colcon build --packages-select composition_example
source install/setup.bash
```

## Running the Examples

### Example 1: Talker/Listener (Composed)

```bash
ros2 launch composition_example talker_listener.launch.py
```

**Expected Output**:
```
[talker]: Publishing: 'Hello World: 0'
[listener]: I heard: 'Hello World: 0'
[talker]: Publishing: 'Hello World: 1'
[listener]: I heard: 'Hello World: 1'
```

**What's happening**:
- Both nodes run in SAME process
- Messages passed by pointer (zero-copy)
- No serialization overhead

### Example 2: Image Pipeline (Composed - Fast)

```bash
ros2 launch composition_example composed.launch.py
```

**Expected Output**:
```
[image_producer]: Published frame 30
[image_processor]: Processed frame 30 (size: 921600 bytes)
```

**Performance**:
- 640x480 RGB image = ~900 KB per frame
- 30 FPS = ~27 MB/s data rate
- **Zero-copy**: Direct pointer passing (fast!)
- Latency: ~1-2 ms

**Monitoring**:
```bash
# Check topic rates
ros2 topic hz /image_raw
ros2 topic hz /image_processed

# Monitor CPU usage
top -p $(pgrep -f component_container)
```

### Example 3: Image Pipeline (Separate - Slow)

For comparison, run the SAME nodes as separate processes:

```bash
ros2 launch composition_example separate.launch.py
```

**Expected Output**:
- Same functional behavior
- **Higher latency** (~10-50 ms)
- **Higher CPU usage** (serialization/deserialization)
- **More memory** (copies of messages)

**Performance Comparison**:
```bash
# Monitor both approaches side-by-side
# Terminal 1: Composed
ros2 launch composition_example composed.launch.py

# Terminal 2: Monitor latency
ros2 topic echo /image_processed --field header.stamp

# Try separate.launch.py and compare!
```

## Manual Composition (Advanced)

### Method 1: Start Container and Load Components

**Terminal 1** - Start empty container:
```bash
ros2 run rclcpp_components component_container
```

**Terminal 2** - Load components:
```bash
# Load producer
ros2 component load /ComponentManager composition_example composition_example::ImageProducerComponent

# Load processor
ros2 component load /ComponentManager composition_example composition_example::ImageProcessorComponent
```

**Terminal 3** - Monitor:
```bash
# List loaded components
ros2 component list

# Unload component
ros2 component unload /ComponentManager 1
```

### Method 2: Run as Standalone

Components can also run as regular nodes:

```bash
# Run talker standalone
ros2 run composition_example talker_node

# Run listener standalone (in another terminal)
ros2 run composition_example listener_node
```

This uses the `EXECUTABLE` generated by `rclcpp_components_register_node`.

## Performance Analysis

### Composed vs Separate (Image Pipeline)

**Metric** | **Composed** | **Separate** | **Speedup**
-----------|--------------|--------------|------------
Latency | 1-2 ms | 10-50 ms | **10-25x faster**
CPU Usage | 15% | 40% | **63% reduction**
Memory Copies | 0 | 2 | **Zero-copy**
Message Serialization | No | Yes | **Eliminated**

**When composition matters most**:
- Large messages (images, point clouds, laser scans)
- High frequency (>10 Hz)
- Real-time requirements
- Resource-constrained systems

## Component Architecture

### Regular Node vs Component

**Regular Node**:
```cpp
class MyNode : public rclcpp::Node {
public:
    MyNode() : Node("my_node") {}  // No NodeOptions
};

int main() {  // Has main() function
    rclcpp::init();
    auto node = std::make_shared<MyNode>();
    rclcpp::spin(node);
}
```

**Component Node**:
```cpp
class MyComponent : public rclcpp::Node {
public:
    // MUST take NodeOptions
    explicit MyComponent(const rclcpp::NodeOptions & options)
        : Node("my_component", options) {}
};

// NO main() function!
// Register as component
RCLCPP_COMPONENTS_REGISTER_NODE(MyComponent)
```

### Key Differences

1. **Constructor**: Must accept `NodeOptions`
2. **No main()**: No executable entry point
3. **Registration**: `RCLCPP_COMPONENTS_REGISTER_NODE` macro
4. **Build**: Shared library (`.so`), not executable

## CMakeLists.txt Pattern

```cmake
# Build as shared library
add_library(my_component SHARED src/my_component.cpp)
ament_target_dependencies(my_component rclcpp rclcpp_components)

# Register component (creates plugin + optional standalone executable)
rclcpp_components_register_node(my_component
    PLUGIN "namespace::MyComponent"   # Full class name
    EXECUTABLE my_node                 # Optional standalone executable
)

# Install library
install(TARGETS my_component
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
    RUNTIME DESTINATION bin
)
```

## Launch File Patterns

### Composed Launch

```python
from launch_ros.actions import ComposableNodeContainer
from launch_ros.descriptions import ComposableNode

container = ComposableNodeContainer(
    name='my_container',
    namespace='',
    package='rclcpp_components',
    executable='component_container',
    composable_node_descriptions=[
        ComposableNode(
            package='my_package',
            plugin='namespace::MyComponent',
            name='my_node',
            extra_arguments=[{'use_intra_process_comms': True}]
        )
    ],
    output='screen'
)
```

### Separate Launch

```python
from launch_ros.actions import Node

node = Node(
    package='my_package',
    executable='my_node',  # From EXECUTABLE in CMakeLists
    name='my_node',
    output='screen'
)
```

## Debugging Composition

### Check Available Components

```bash
# List all component plugins
ros2 component types

# Check specific package
ros2 component types composition_example
```

**Expected Output**:
```
composition_example::ImageProducerComponent
composition_example::ImageProcessorComponent
composition_example::TalkerComponent
composition_example::ListenerComponent
```

### Runtime Monitoring

```bash
# List running containers
ros2 component list

# Show components in specific container
ros2 component list /my_container
```

### Common Issues

**1. Component Not Found**
```
Error: Could not find component 'MyComponent'
```
- Check plugin name matches `RCLCPP_COMPONENTS_REGISTER_NODE`
- Rebuild: `colcon build --packages-select composition_example`
- Source: `source install/setup.bash`

**2. Segmentation Fault**
```
Segmentation fault (core dumped)
```
- Ensure `NodeOptions` passed to base class constructor
- Check all shared_ptr are properly initialized

**3. Zero-Copy Not Working**
```
Still seeing high latency/CPU
```
- Verify `use_intra_process_comms: True` in launch file
- Ensure both nodes in SAME container
- Use `unique_ptr` for publishing: `publish(std::move(msg))`

## Performance Best Practices

### 1. Use unique_ptr for Publishing

```cpp
// Good: Enables zero-copy
auto msg = std::make_unique<Image>();
publisher_->publish(std::move(msg));

// Bad: Creates copy
auto msg = std::make_shared<Image>();
publisher_->publish(*msg);
```

### 2. Enable Intra-Process Comms

```python
extra_arguments=[{'use_intra_process_comms': True}]
```

### 3. Use Same Container

All nodes must be in SAME `ComposableNodeContainer` for zero-copy.

### 4. Appropriate QoS

```cpp
auto qos = rclcpp::QoS(10).reliable();
publisher_ = this->create_publisher<Image>("topic", qos);
```

## When to Use Composition

**✓ Use Composition**:
- High-frequency data (>10 Hz)
- Large messages (images, point clouds, >100 KB)
- Real-time requirements (latency <10 ms)
- Embedded/resource-constrained systems
- Tight pipeline coupling

**✗ Use Separate Processes**:
- Low-frequency data (<1 Hz)
- Small messages (<1 KB)
- Need crash isolation
- Different programming languages
- Independent development teams

## Related Lessons

- **Lesson 11**: Composition Basics
- **Lesson 12**: Component Nodes

## Next Steps

- Convert existing nodes to components
- Measure performance improvements
- Combine with TF2 and actions
- Use in mini-project robot arm
- Explore lifecycle composition
